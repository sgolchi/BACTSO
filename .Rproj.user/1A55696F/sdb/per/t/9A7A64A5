{
    "collab_server" : "",
    "contents" : "#' @import Rcpp\n#' @import rstantools\n#' @useDynLib add.adp, .registration = TRUE\n#' @importFrom stats pnorm\n#' @importFrom stats rbinom\n#' @importFrom stats rmultinom\n#' @importFrom stats rnorm\n#' @importFrom stats sd\n#' @importFrom stats var\n#' @importFrom ggplot2 ggplot\n#' @importFrom ggplot2 aes\n#' @importFrom ggplot2 geom_point\n#' @importFrom ggplot2 geom_line\n#' @importFrom ggplot2 geom_hline\n#' @importFrom ggplot2 geom_density\n#' @importFrom ggplot2 facet_grid\n#' @importFrom ggplot2 scale_color_brewer\n#' @importFrom ggplot2 scale_fill_brewer\n#' @importFrom ggplot2 xlim\n#' @importFrom ggplot2 ylim\n#' @importFrom ggplot2 xlab\n#' @importFrom ggplot2 ylab\n#' @importFrom reshape2 melt\n#' @importFrom dplyr %>%\n#' @importFrom dplyr group_by\n#' @importFrom dplyr summarise\n\n\nlogit = function(P) return(- log(P/(1-P)))\nlogistic = function(theta) return( 1 -  exp(theta)/(1 + exp(theta)))\n\n\nsim_01 = function(N, P_a, PF_var = 1) {\n  theta_a = logit(P_a)\n  lPF = rnorm(N, 0, PF_var)\n  mu = lPF + theta_a\n  p0 = 1 - exp(mu)/(1 + exp(mu))\n  return(rbinom(N, size = 1, prob = p0))\n}\n\nsim_02 = function(N, P_a, P_b, p, PF_var = 1) {\n  theta_a = logit(P_a)\n  theta_b = logit(P_b)\n  theta_c = max(theta_a, theta_b) + p * min(theta_a, theta_b)\n  lPF = rnorm(N, 0, PF_var)\n  mu = lPF + theta_c\n  p0 = 1 - exp(mu)/(1 + exp(mu))\n  return(rbinom(N, size = 1, prob = p0))\n}\n\n\np_ab = function(x) {\n  P_a = x[1]\n  P_b = x[2]\n  p = x[3]\n  return(logistic(max(logit(P_a), logit(P_b)) + p * min(logit(P_a), logit(P_b))))\n}\n\n\nunlist_df = function(df) {\n  df = data.frame(apply(df, 2, unlist))\n  return(df)\n}\n\n\npos = function(x, y, x_sd, y_sd, thresh){\n  return(pnorm(0, y - x, sqrt(x_sd^2 + y_sd^2)) > thresh)\n}\n\n\nss = function(par){\n  P_a = par[1]\n  P_b = par[2]\n  p = par[3]\n  P_ab = logistic(max(logit(P_a), logit(P_b)) + p * min(logit(P_a), logit(P_b)))\n  n1 = floor(((P_a * (1 - P_a) + P_ab * (1 - P_ab)) / (P_a - P_ab)^2)* 7.9)\n  n2 = floor(((P_b * (1 - P_b) + P_ab * (1 - P_ab)) / (P_b - P_ab)^2)* 7.9)\n  return(max(n1, 2))\n}\n\n#' RAR trial simulator with fractional additivity assumption\n#'\n#' This function simulates a three arm response adaptive randomized trial where one treatment\n#' is a combination of the other two and fractional additivity is assumed\n#' @param p fractional additivity parameter\n#' @param P_a probability of response with treatment A\n#' @param P_b probability of response with treatment B\n#' @param PF_var prognostic factor variance\n#' @param pmean0 prior mean of p\n#' @param pvar0 prior variance of p\n#' @param np number of batches the total sample size is split into: determines what fraction\n#' of the sample size is used between two interim looks\n#' @param nadapt number of interim looks (adaptations) including the last analysis\n#' @export\n#' @return An object of class \\code{trial}: posterior samples for the model parameters through the interim\n#' course of teh trial and probabilities of superiority for each of the treatment arms\n#' @examples\n#' trial_RAR()\n\ntrial_RAR = function(p = .25, P_a = .4, P_b = .4, PF_var = 1, pmean0 = p, pvar0 = .16,\n                     np = 5, nadapt = 5) {\n  theta = logit(c(P_a, P_b, p_ab(c(P_a, P_b, p))))\n  N0 = ss(c(P_a, P_b, p))\n  N = floor(3 * N0 / np)\n  a0 = pmean0\n  b0 = sqrt(pvar0)\n  theta_mean = array(dim = c(2, nadapt))\n  theta_sd = array(dim = c(2, nadapt))\n  theta_mean[,1] = rep(0, 2)\n  theta_sd[,1] = rep(10, 2)\n  pmean = NULL\n  pvar = NULL\n  pa = NULL\n  pb = NULL\n  pab = NULL\n  pa[1] = 1/3\n  pb[1] = 1/3\n  pab[1] = 1/3\n  fp = NULL\n  fp[1] = 0\n  i = 1\n  samples = NULL\n  data = list(a0 = a0, b0 = b0, theta_mean = theta_mean[,1], theta_sd = theta_sd[,1])\n  #fit3 = rstan::stan(file ='RAR_sample_prior.stan', data = data, chains = 0)\n  fit3 = rstan::sampling(stanmodels$RAR_sample_prior, 'data'= data, warmup = 1000, iter = 2000, chains = 1)\n  fit_ss = rstan::extract(fit3)\n  samples = abind::abind(samples, cbind(as.data.frame(fit_ss), batch = rep(0, 500)), along = 1)\n  repeat {\n    i = i + 1\n    prob = sqrt(c(pa[i-1], pb[i-1], pab[i-1]))\n    prob[prob < .05] = .05\n    n = rmultinom(1, N, prob = prob)\n    z = c(sim_01(n[1], P_a, PF_var), sim_01(n[2], P_b, PF_var), sim_02(n[3], P_a, P_b, p, PF_var))\n    treat_a = c(rep(1, n[1]), rep(0, n[2]), rep(0, n[3]))\n    treat_b = c(rep(0, n[1]), rep(1, n[2]), rep(0, n[3]))\n    treat_ab = c(rep(0, n[1]), rep(0, n[2]), rep(1, n[3]))\n    initf1 = function() {\n      list(theta = c(logit(P_a), logit(P_b)), p = p)\n    }\n    initl = list(initf1())\n    data = list(N = sum(n), treat_a = treat_a, treat_b = treat_b, treat_ab = treat_ab, a0 = a0,\n                b0 = b0, theta_mean = theta_mean[,i-1], theta_sd = theta_sd[,i-1], y = 1 - z)\n    #fit0 = rstan::stan(file ='logistic_add_rar.stan', data = data, chains = 0, init = initf1)\n    fit0 = rstan::sampling(stanmodels$logistic_add_rar, 'data'= data, warmup = 1000, iter = 2000, chains = 1, init = initl)\n    fit_ss = rstan::extract(fit0)\n    samples = abind::abind(samples, cbind(as.data.frame(fit_ss), batch = rep(i - 1, 500)), along = 1)\n    theta_mean[,i] = apply(fit_ss$theta, 2, mean)\n    theta_sd[,i] = apply(fit_ss$theta, 2, sd)\n    pmean[i] = mean(fit_ss$p)\n    pvar[i] = var(fit_ss$p)\n    a0 = pmean[i]\n    b0 = sqrt(pvar[i])\n    pa[i] = ifelse(mean(fit_ss$a) > .01, mean(fit_ss$a), 0)\n    pb[i] = ifelse(mean(fit_ss$b) > .01, mean(fit_ss$b), 0)\n    pab[i] = ifelse(mean(fit_ss$ab) > .01, mean(fit_ss$ab), 0)\n    fp[i] = mean(z)\n    if (pab[i] >= .95 | pa[i] >= .95 | pb[i] >= .95 | (pa[i] == 0 & pb[i] == 0) |\n        (pab[i] == 0 & pb[i] == 0) | (pab[i] == 0 & pa[i] == 0) | i == nadapt) break\n  }\n  trial = list(samples = as.data.frame(samples), pa = pa, pb = pb, pab = pab)\n  class(trial) = 'trial'\n  return(trial)\n}\n\n\n\n#' Wrapper function for \\code{trial_RAR}\n#'\n#' @param p fractional additivity parameter\n#' @param P_a probability of response with treatment A\n#' @param P_b probability of response with treatment B\n#' @param PF_var prognostic factor variance\n#' @param pmean0 prior mean of p\n#' @param pvar0 prior variance of p\n#' @param np number of batches the total sample size is split into: determines what fraction\n#' of the sample size is used between two interim looks\n#' @param nadapt number of interim looks (adaptations) including the last analysis\n#' @export\n#' @return a data frame containing: number of batches \\code{nb}, realized sample size at\n#' trial termination \\code{RN}, proportion of failures \\code{FP}, and mean squared error for\n#' the effect size estimates\n#' @examples\n#' trial_add_RAR()\n\ntrial_add_RAR = function(j, p = .75, P_a = .4, P_b = .4, PF_var = 1, pmean0 = p, pvar0 = .16,\n                         np = 5, nadapt = 6) {\n  P_ab = p_ab(c(P_a, P_b, p))\n  theta = logit(c(P_a, P_b, p_ab(c(P_a, P_b, p))))\n  N0 = ss(c(P_a, P_b, p))\n  N = floor(3 * N0 / np)\n  a0 = pmean0\n  b0 = sqrt(pvar0)\n  theta_mean = array(dim = c(2, nadapt))\n  theta_sd = array(dim = c(2, nadapt))\n  theta_mean[,1] = rep(0, 2)\n  theta_sd[,1] = rep(10, 2)\n  pmean = NULL\n  pvar = NULL\n  pa = NULL\n  pb = NULL\n  pab = NULL\n  pa[1] = 1/3\n  pb[1] = 1/3\n  pab[1] = 1/3\n  fp = NULL\n  fp[1] = 0\n  i = 1\n  repeat {\n    i = i + 1\n    prob = sqrt(c(pa[i-1], pb[i-1], pab[i-1]))\n    prob[prob < .05] = .05\n    n = rmultinom(1, N, prob = prob)\n    z = c(sim_01(n[1], P_a, PF_var), sim_01(n[2], P_b, PF_var), sim_02(n[3], P_a, P_b, p, PF_var))\n    treat_a = c(rep(1, n[1]), rep(0, n[2]), rep(0, n[3]))\n    treat_b = c(rep(0, n[1]), rep(1, n[2]), rep(0, n[3]))\n    treat_ab = c(rep(0, n[1]), rep(0, n[2]), rep(1, n[3]))\n    initf1 = function() {\n      list(theta = c(logit(P_a), logit(P_b)), p = p)\n    }\n    initl = list(initf1())\n    data = list(N = sum(n), treat_a = treat_a, treat_b = treat_b, treat_ab = treat_ab, a0 = a0,\n                b0 = b0, theta_mean = theta_mean[,i-1], theta_sd = theta_sd[,i-1], y = 1 - z)\n    #fit0 = rstan::stan(file ='logistic_add_rar.stan', data = data, chains = 0, init = initf1)\n    fit0 = rstan::sampling(stanmodels$logistic_add_rar, 'data'= data, warmup = 250, iter = 500, chains = 1, init = initl)\n    fit_ss = rstan::extract(fit0)\n    theta_mean[,i] = apply(fit_ss$theta, 2, mean)\n    theta_sd[,i] = apply(fit_ss$theta, 2, sd)\n    pmean[i] = mean(fit_ss$p)\n    pvar[i] = var(fit_ss$p)\n    a0 = pmean[i]#((1 - pmean[i]) / pvar[i] - 1 / pmean[i]) * pmean[i] ^ 2\n    b0 = sqrt(pvar[i])#((1 - pmean[i]) / pvar[i] - 1 / pmean[i]) * pmean[i] * (1 - pmean[i])\n    pa[i] = ifelse(mean(fit_ss$a) > .01, mean(fit_ss$a), 0)\n    pb[i] = ifelse(mean(fit_ss$b) > .01, mean(fit_ss$b), 0)\n    pab[i] = ifelse(mean(fit_ss$ab) > .01, mean(fit_ss$ab), 0)\n    fp[i] = mean(z)\n    if (pab[i] >= .95 | pa[i] >= .95 | pb[i] >= .95 | (pa[i] == 0 & pb[i] == 0) |\n        (pab[i] == 0 & pb[i] == 0) | (pab[i] == 0 & pa[i] == 0) | i == nadapt) break\n  }\n  out = data.frame(nb = (i-1), RN = (i-1)*N, FP = mean(fp), MSE_ab0 = mean((fit_ss$theta_ab - theta[3])^2),\n                   MSE_a0 = mean((fit_ss$theta[,1] - theta[1])^2),\n                   MSE_b0 = mean((fit_ss$theta[,2] - theta[2])^2),\n                   bias_a = mean(fit_ss$P_a - P_a), \n                   bias_b = mean(fit_ss$P_b - P_b),\n                   bias_ab = mean(fit_ss$P_ab - P_ab))\n  return(out)\n}\n\n#' Trial simulation function with full additivity assumption\n#' \n#' @param P_a probability of response with treatment A\n#' @param P_b probability of response with treatment B\n#' @param PF_var prognostic factor variance\n#' @param np number of batches the total sample size is split into: determines what fraction\n#' of the sample size is used between two interim looks\n#' @param nadapt number of interim looks (adaptations) including the last analysis\n#' @export\n#' @return a data frame containing: number of batches \\code{nb}, realized sample size at\n#' trial termination \\code{RN}, proportion of failures \\code{FP}, and mean squared error for\n#' the effect size estimates\n#' @examples\n#' trial_full_add()\n\ntrial_full_add = function(j, p = .75, P_a = .4, P_b = .4, PF_var = 1, np = 5, nadapt = 6) {\n  P_ab = p_ab(c(P_a, P_b, p))\n  theta = logit(c(P_a, P_b, p_ab(c(P_a, P_b, p))))\n  N0 = ss(c(P_a, P_b, p))\n  N = floor(3 * N0 / np)\n  theta_mean = array(dim = c(2, nadapt))\n  theta_sd = array(dim = c(2, nadapt))\n  theta_mean[,1] = rep(0, 2)\n  theta_sd[,1] = rep(10, 2)\n  pmean = NULL\n  pvar = NULL\n  pa = NULL\n  pb = NULL\n  pab = NULL\n  pa[1] = 1/3\n  pb[1] = 1/3\n  pab[1] = 1/3\n  fp = NULL\n  fp[1] = 0\n  i = 1\n  repeat {\n    i = i + 1\n    prob = sqrt(c(pa[i-1], pb[i-1], pab[i-1]))\n    prob[prob < .05] = .05\n    n = rmultinom(1, N, prob = prob)\n    z = c(sim_01(n[1], P_a, PF_var), sim_01(n[2], P_b, PF_var), sim_02(n[3], P_a, P_b, p, PF_var))\n    treat_a = c(rep(1, n[1]), rep(0, n[2]), rep(0, n[3]))\n    treat_b = c(rep(0, n[1]), rep(1, n[2]), rep(0, n[3]))\n    treat_ab = c(rep(0, n[1]), rep(0, n[2]), rep(1, n[3]))\n    initf1 = function() {\n      list(theta = c(logit(P_a), logit(P_b)), p = p)\n    }\n    initl = list(initf1())\n    data = list(N = sum(n), treat_a = treat_a, treat_b = treat_b, treat_ab = treat_ab, theta_mean = theta_mean[,i-1], theta_sd = theta_sd[,i-1], y = 1 - z)\n    #fit0 = rstan::stan(file ='logistic_add_rar.stan', data = data, chains = 0, init = initf1)\n    fit0 = rstan::sampling(stanmodels$logistic_full_add, 'data'= data, warmup = 250, iter = 500, chains = 1, init = initl)\n    fit_ss = rstan::extract(fit0)\n    theta_mean[,i] = apply(fit_ss$theta, 2, mean)\n    theta_sd[,i] = apply(fit_ss$theta, 2, sd)\n    pa[i] = ifelse(mean(fit_ss$a) > .01, mean(fit_ss$a), 0)\n    pb[i] = ifelse(mean(fit_ss$b) > .01, mean(fit_ss$b), 0)\n    pab[i] = ifelse(mean(fit_ss$ab) > .01, mean(fit_ss$ab), 0)\n    fp[i] = mean(z)\n    if (pab[i] >= .95 | pa[i] >= .95 | pb[i] >= .95 | (pa[i] == 0 & pb[i] == 0) |\n        (pab[i] == 0 & pb[i] == 0) | (pab[i] == 0 & pa[i] == 0) | i == nadapt) break\n  }\n  out = data.frame(nb = (i-1), RN = (i-1)*N, FP = mean(fp), MSE_ab0 = mean((fit_ss$theta_ab - theta[3])^2),\n                   MSE_a0 = mean((fit_ss$theta[,1] - theta[1])^2),\n                   MSE_b0 = mean((fit_ss$theta[,2] - theta[2])^2),\n                   bias_a = mean(fit_ss$P_a - P_a), \n                   bias_b = mean(fit_ss$P_b - P_b),\n                   bias_ab = mean(fit_ss$P_ab - P_ab))\n  return(out)\n}\n\n\n#' RAR trial simulator (conventional)\n#'\n#' This function simulates a three arm response adaptive randomized trial where one treatment\n#' is a combination of the other two but this is ignored as in conventional methods\n#' @param p fractional additivity parameter\n#' @param P_a probability of response with treatment A\n#' @param P_b probability of response with treatment B\n#' @param PF_var prognostic factor variance\n#' @param np number of batches the total sample size is split into: determines what fraction\n#' of the sample size is used between two interim looks\n#' @param nadapt number of interim looks (adaptations) including the last analysis\n#' @export\n#' @return a data frame containing: number of batches \\code{nb}, realized sample size at\n#' trial termination \\code{RN}, proportion of failures \\code{FP}, and mean squared error for\n#' the effect size estimates\n#' @examples\n#' trial_std_RAR()\ntrial_std_RAR = function(j, p = .75, P_a = .4, P_b = .4, PF_var = 1, np = 5, nadapt = 6) {\n  P_ab = p_ab(c(P_a, P_b, p))\n  theta = logit(c(P_a, P_b, p_ab(c(P_a, P_b, p))))\n  N0 = ss(c(P_a, P_b, p))\n  N = floor(3 * N0 / np)\n  theta_mean = array(dim = c(3, nadapt))\n  theta_sd = array(dim = c(3, nadapt))\n  theta_mean[,1] = rep(0, 3)\n  theta_sd[,1] = rep(10, 3)\n  pa = NULL\n  pb = NULL\n  pab = NULL\n  pa[1] = 1/3\n  pb[1] = 1/3\n  pab[1] = 1/3\n  fp = NULL\n  fp[1] = 0\n  i = 1\n  repeat {\n    i = i + 1\n    prob = sqrt(c(pa[i-1], pb[i-1], pab[i-1]))\n    prob[prob < .05] = .05\n    n = rmultinom(1, N, prob = prob)\n    z = c(sim_01(n[1], P_a, PF_var), sim_01(n[2], P_b, PF_var), sim_02(n[3], P_a, P_b, p, PF_var))\n    treat_a = c(rep(1, n[1]), rep(0, n[2]), rep(0, n[3]))\n    treat_b = c(rep(0, n[1]), rep(1, n[2]), rep(0, n[3]))\n    treat_ab = c(rep(0, n[1]), rep(0, n[2]), rep(1, n[3]))\n    data = list(N = sum(n), treat_a = treat_a, treat_b = treat_b, treat_ab = treat_ab,\n                theta_mean = theta_mean[,i-1], theta_sd = theta_sd[,i-1], y = 1 - z)\n    #fit1 = rstan::stan(file ='logistic_rar.stan', data = data, chains = 0)\n    fit1 = rstan::sampling(stanmodels$logistic_rar, 'data'= data, warmup = 250, iter = 500, chains = 1)\n    fit_ss = rstan::extract(fit1)\n    theta_mean[,i] = apply(fit_ss$theta, 2, mean)\n    theta_sd[,i] = apply(fit_ss$theta, 2, sd)\n    pa[i] = ifelse(mean(fit_ss$a) > .01, mean(fit_ss$a), 0)\n    pb[i] = ifelse(mean(fit_ss$b) > .01, mean(fit_ss$b), 0)\n    pab[i] = ifelse(mean(fit_ss$ab) > .01, mean(fit_ss$ab), 0)\n    fp[i] = mean(z)\n    if (pab[i] >= .95 | pa[i] >= .95 | pb[i] >= .95 | (pa[i] == 0 & pb[i] == 0) |\n        (pab[i] == 0 & pb[i] == 0) | (pab[i] == 0 & pa[i] == 0) | i == nadapt) break\n  }\n  out = data.frame(nb = (i-1), RN = (i-1)*N, FP = mean(fp), MSE_ab0 = mean((fit_ss$theta[,3] - theta[3])^2),\n                   MSE_a0 = mean((fit_ss$theta[,1] - theta[1])^2),\n                   MSE_b0 = mean((fit_ss$theta[,2] - theta[2])^2),\n                   bias_a = mean(fit_ss$P_a - P_a), \n                   bias_b = mean(fit_ss$P_b - P_b),\n                   bias_ab = mean(fit_ss$P_ab - P_ab))\n  return(out)\n}\n\n\n#' output cleanup\n#'\n#' @param df a data frame of output\n#' @export\n\nunlist_df = function(df) {\n  df = data.frame(apply(df, 2, unlist))\n  return(df)\n}\n\n#' RAR trial simulator with fractional additivity assumption\n#'\n#' This function simulates trial \\code{M} times\n#' @inheritParams trial_add_RAR\n#' @export\n#' @param M number of simulation iterations\ntrial_add_RAR_sim = function(p = .25, P_a = .4, P_b = .4, PF_var = 1, pmean0 = p, pvar0 = .16,\n                             np = 5, nadapt = 6, M ) {\n  out = unlist_df(data.frame(t(sapply(1:M, trial_add_RAR, p = p, P_a = P_a, P_b = P_b, PF_var = PF_var, pmean0 = pmean0,\n                                      pvar0 = pvar0, np = np, nadapt = nadapt, simplify = T))))\n  return(out)\n}\n\n#' RAR trial simulator with full additivity assumption\n#'\n#' This function simulates trial \\code{M} times\n#' @inheritParams trial_full_add\n#' @export\n#' @param M number of simulation iterations\ntrial_add_full_sim = function(p = .25, P_a = .4, P_b = .4, PF_var = 1, np = 5, nadapt = 6, M ) {\n  out = unlist_df(data.frame(t(sapply(1:M, trial_full_add, p = p, P_a = P_a, P_b = P_b, PF_var = PF_var, np = np, \n                                       nadapt = nadapt, simplify = T))))\n  return(out)\n}\n\n#' RAR trial simulator ignoring fractional additivity\n#'\n#' This function simulates trial \\code{M} times\n#' @inheritParams trial_std_RAR\n#' @export\n#' @param M number of simulation iterations\ntrial_std_RAR_sim = function(p = .25, P_a = .4, P_b = .4, PF_var = 1, np = 5, nadapt = 6, M) {\n  out = unlist_df(data.frame(t(sapply(1:M, trial_std_RAR,  p = p, P_a = P_a, P_b = P_b, PF_var = PF_var, np = np,\n                                      nadapt = nadapt, simplify = T))))\n  return(out)\n}\n\n########################################################################################################\n\n#' Fixed sample trial simulator frac.add\n#'\n#' @param p fractional additivity parameter\n#' @param P_a probability of response with treatment A\n#' @param P_b probability of response with treatment B\n#' @param PF_var prognostic factor variance\n#' @param pmean0 prior mean of p\n#' @param pvar0 prior variance of p\n#' @param np number of batches the total sample size is split into: determines what fraction\n#' of the sample size is used between two interim looks\n#' @param nadapt number of interim looks (adaptations) including the last analysis\n#' @export\n#' @return a data frame of probabilities of superiority\n#' @examples\n#' trial_add_fix()\n\ntrial_add_fix = function(j, p = .75, P_a = .4, P_b = .4, PF_var = 1, pmean0 = p, pvar0 = .16,\n                         np = 5, nadapt = 6) {\n  P_ab = p_ab(c(P_a, P_b, p))\n  theta = logit(c(P_a, P_b, p_ab(c(P_a, P_b, p))))\n  N0 = ss(c(P_a, P_b, p))\n  N = floor(3 * N0 / np)\n  a0 = pmean0\n  b0 = sqrt(pvar0)\n  theta_mean = array(dim = c(2, nadapt))\n  theta_sd = array(dim = c(2, nadapt))\n  theta_mean[,1] = rep(0, 2)\n  theta_sd[,1] = rep(10, 2)\n  pmean = NULL\n  pvar = NULL\n  pa = NULL\n  pb = NULL\n  pab = NULL\n  pa[1] = 1/3\n  pb[1] = 1/3\n  pab[1] = 1/3\n  fp = NULL\n  fp[1] = 0\n  #i = 1\n  for (i in 2:nadapt) {\n    prob = sqrt(c(pa[i-1], pb[i-1], pab[i-1]))\n    prob[prob < .05] = .05\n    n = rmultinom(1, N, prob = c(1/3, 1/3, 1/3))\n    z = c(sim_01(n[1], P_a, PF_var), sim_01(n[2], P_b, PF_var), sim_02(n[3], P_a, P_b, p, PF_var))\n    treat_a = c(rep(1, n[1]), rep(0, n[2]), rep(0, n[3]))\n    treat_b = c(rep(0, n[1]), rep(1, n[2]), rep(0, n[3]))\n    treat_ab = c(rep(0, n[1]), rep(0, n[2]), rep(1, n[3]))\n    initf1 = function() {\n      list(theta = c(logit(P_a), logit(P_b)), p = p)\n    }\n    initl = list(initf1())\n    data = list(N = sum(n), treat_a = treat_a, treat_b = treat_b, treat_ab = treat_ab, a0 = a0,\n                b0 = b0, theta_mean = theta_mean[,i-1], theta_sd = theta_sd[,i-1], y = 1 - z)\n    #fit0 = rstan::stan(file ='logistic_add_rar.stan', data = data, chains = 0, init = initf1)\n    fit0 = rstan::sampling(stanmodels$logistic_add_rar, 'data'= data, warmup = 250, iter = 500, chains = 1, init = initl)\n    fit_ss = rstan::extract(fit0)\n    theta_mean[,i] = apply(fit_ss$theta, 2, mean)\n    theta_sd[,i] = apply(fit_ss$theta, 2, sd)\n    pmean[i] = mean(fit_ss$p)\n    pvar[i] = var(fit_ss$p)\n    a0 = pmean[i]#((1 - pmean[i]) / pvar[i] - 1 / pmean[i]) * pmean[i] ^ 2\n    b0 = sqrt(pvar[i])#((1 - pmean[i]) / pvar[i] - 1 / pmean[i]) * pmean[i] * (1 - pmean[i])\n    pa[i] = ifelse(mean(fit_ss$a) > .01, mean(fit_ss$a), 0)\n    pb[i] = ifelse(mean(fit_ss$b) > .01, mean(fit_ss$b), 0)\n    pab[i] = ifelse(mean(fit_ss$ab) > .01, mean(fit_ss$ab), 0)\n    fp[i] = mean(z)\n  }\n  out = data.frame(pab = pab, pa = pa, pb = pb, batch = 0:5)\n  return(out)\n}\n\n#' Trial simulation with fixed sample and full additivity assumption\n#' \n#' @param P_a probability of response with treatment A\n#' @param P_b probability of response with treatment B\n#' @param PF_var prognostic factor variance\n#' @param np number of batches the total sample size is split into: determines what fraction\n#' of the sample size is used between two interim looks\n#' @param nadapt number of interim looks (adaptations) including the last analysis\n#' @export\n#' @return a data frame of pron=babilities of superiority\n#' @examples\n#' trial_full_fix()\n\ntrial_full_fix = function(j, p = .75, P_a = .4, P_b = .4, PF_var = 1, np = 5, nadapt = 6) {\n  P_ab = p_ab(c(P_a, P_b, p))\n  theta = logit(c(P_a, P_b, p_ab(c(P_a, P_b, p))))\n  N0 = ss(c(P_a, P_b, p))\n  N = floor(3 * N0 / np)\n  theta_mean = array(dim = c(2, nadapt))\n  theta_sd = array(dim = c(2, nadapt))\n  theta_mean[,1] = rep(0, 2)\n  theta_sd[,1] = rep(10, 2)\n  pmean = NULL\n  pvar = NULL\n  pa = NULL\n  pb = NULL\n  pab = NULL\n  pa[1] = 1/3\n  pb[1] = 1/3\n  pab[1] = 1/3\n  fp = NULL\n  fp[1] = 0\n  for (i in 2:nadapt) {\n    prob = sqrt(c(pa[i-1], pb[i-1], pab[i-1]))\n    prob[prob < .05] = .05\n    n = rmultinom(1, N, prob = c(1/3, 1/3, 1/3))\n    z = c(sim_01(n[1], P_a, PF_var), sim_01(n[2], P_b, PF_var), sim_02(n[3], P_a, P_b, p, PF_var))\n    treat_a = c(rep(1, n[1]), rep(0, n[2]), rep(0, n[3]))\n    treat_b = c(rep(0, n[1]), rep(1, n[2]), rep(0, n[3]))\n    treat_ab = c(rep(0, n[1]), rep(0, n[2]), rep(1, n[3]))\n    initf1 = function() {\n      list(theta = c(logit(P_a), logit(P_b)), p = p)\n    }\n    initl = list(initf1())\n    data = list(N = sum(n), treat_a = treat_a, treat_b = treat_b, treat_ab = treat_ab, theta_mean = theta_mean[,i-1], theta_sd = theta_sd[,i-1], y = 1 - z)\n    #fit0 = rstan::stan(file ='logistic_add_rar.stan', data = data, chains = 0, init = initf1)\n    fit0 = rstan::sampling(stanmodels$logistic_full_add, 'data'= data, warmup = 250, iter = 500, chains = 1, init = initl)\n    fit_ss = rstan::extract(fit0)\n    theta_mean[,i] = apply(fit_ss$theta, 2, mean)\n    theta_sd[,i] = apply(fit_ss$theta, 2, sd)\n    pa[i] = ifelse(mean(fit_ss$a) > .01, mean(fit_ss$a), 0)\n    pb[i] = ifelse(mean(fit_ss$b) > .01, mean(fit_ss$b), 0)\n    pab[i] = ifelse(mean(fit_ss$ab) > .01, mean(fit_ss$ab), 0)\n    fp[i] = mean(z)\n  }\n  out = data.frame(pab = pab, pa = pa, pb = pb, batch = 0:5)\n  return(out)\n}\n\n\n#' RAR trial simulator fixed sample (conventional)\n#'\n#' This function simulates a three arm response adaptive randomized trial where one treatment\n#' is a combination of the other two but this is ignored as in conventional methods\n#' @param p fractional additivity parameter\n#' @param P_a probability of response with treatment A\n#' @param P_b probability of response with treatment B\n#' @param PF_var prognostic factor variance\n#' @param np number of batches the total sample size is split into: determines what fraction\n#' of the sample size is used between two interim looks\n#' @param nadapt number of interim looks (adaptations) including the last analysis\n#' @export\n#' @return a data frame containing probabilities of superiority\n#' @examples\n#' trial_std_fix()\ntrial_std_fix = function(j, p = .75, P_a = .4, P_b = .4, PF_var = 1, np = 5, nadapt = 6) {\n  P_ab = p_ab(c(P_a, P_b, p))\n  theta = logit(c(P_a, P_b, p_ab(c(P_a, P_b, p))))\n  N0 = ss(c(P_a, P_b, p))\n  N = floor(3 * N0 / np)\n  theta_mean = array(dim = c(3, nadapt))\n  theta_sd = array(dim = c(3, nadapt))\n  theta_mean[,1] = rep(0, 3)\n  theta_sd[,1] = rep(10, 3)\n  pa = NULL\n  pb = NULL\n  pab = NULL\n  pa[1] = 1/3\n  pb[1] = 1/3\n  pab[1] = 1/3\n  fp = NULL\n  fp[1] = 0\n  for (i in 2:nadapt) {\n    prob = sqrt(c(pa[i-1], pb[i-1], pab[i-1]))\n    prob[prob < .05] = .05\n    n = rmultinom(1, N, prob = c(1/3, 1/3, 1/3))\n    z = c(sim_01(n[1], P_a, PF_var), sim_01(n[2], P_b, PF_var), sim_02(n[3], P_a, P_b, p, PF_var))\n    treat_a = c(rep(1, n[1]), rep(0, n[2]), rep(0, n[3]))\n    treat_b = c(rep(0, n[1]), rep(1, n[2]), rep(0, n[3]))\n    treat_ab = c(rep(0, n[1]), rep(0, n[2]), rep(1, n[3]))\n    data = list(N = sum(n), treat_a = treat_a, treat_b = treat_b, treat_ab = treat_ab,\n                theta_mean = theta_mean[,i-1], theta_sd = theta_sd[,i-1], y = 1 - z)\n    #fit1 = rstan::stan(file ='logistic_rar.stan', data = data, chains = 0)\n    fit1 = rstan::sampling(stanmodels$logistic_rar, 'data'= data, warmup = 250, iter = 500, chains = 1)\n    fit_ss = rstan::extract(fit1)\n    theta_mean[,i] = apply(fit_ss$theta, 2, mean)\n    theta_sd[,i] = apply(fit_ss$theta, 2, sd)\n    pa[i] = ifelse(mean(fit_ss$a) > .01, mean(fit_ss$a), 0)\n    pb[i] = ifelse(mean(fit_ss$b) > .01, mean(fit_ss$b), 0)\n    pab[i] = ifelse(mean(fit_ss$ab) > .01, mean(fit_ss$ab), 0)\n    fp[i] = mean(z)\n  }\n  out = data.frame(pab = pab, pa = pa, pb = pb, batch = 0:5)\n  return(out)\n}\n\n\n#' RAR trial simulator with fixed sample and  fractional additivity assumption\n#'\n#' This function simulates trial \\code{M} times\n#' @inheritParams trial_add_fix\n#' @export\n#' @param M number of simulation iterations\ntrial_add_fix_sim = function(p = .5, P_a = .4, P_b = .4, PF_var = 1, pmean0 = p, pvar0 = .16,\n                             np = 5, nadapt = 6, M ) {\n  out = unlist_df(data.frame(t(sapply(1:M, trial_add_fix, p = p, P_a = P_a, P_b = P_b, PF_var = PF_var, pmean0 = pmean0,\n                                      pvar0 = pvar0, np = np, nadapt = nadapt, simplify = T))))\n  return(out)\n}\n\n#' RAR trial simulator fixed sample with full additivity assumption\n#'\n#' This function simulates trial \\code{M} times\n#' @inheritParams trial_full_fix\n#' @export\n#' @param M number of simulation iterations\ntrial_fix_full_sim = function(p = .5, P_a = .4, P_b = .4, PF_var = 1, np = 5, nadapt = 6, pmean0 = p, M ) {\n  out = unlist_df(data.frame(t(sapply(1:M, trial_full_fix, p = p, P_a = P_a, P_b = P_b, PF_var = PF_var, \n                                      pmean0 = pmean0, np = np, nadapt = nadapt, simplify = T))))\n  return(out)\n}\n\n#' RAR trial simulator fixed sample ignoring fractional additivity\n#'\n#' This function simulates trial \\code{M} times\n#' @inheritParams trial_std_fix\n#' @export\n#' @param M number of simulation iterations\ntrial_std_fix_sim = function(p = .5, P_a = .4, P_b = .4, PF_var = 1, np = 5, nadapt = 6, pmean0 = p, M) {\n  out = unlist_df(data.frame(t(sapply(1:M, trial_std_fix,  p = p, P_a = P_a, P_b = P_b, PF_var = PF_var, np = np,\n                                      pmean0 = pmean0, nadapt = nadapt, simplify = T))))\n  return(out)\n}\n\n\n",
    "created" : 1505851038287.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2546570320",
    "id" : "9A7A64A5",
    "lastKnownWriteTime" : 1508176821,
    "last_content_update" : 1508176821255,
    "path" : "~/Dropbox/clinical_trials/additivity_paper/add.adp/R/sim_funs.R",
    "project_path" : "R/sim_funs.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}